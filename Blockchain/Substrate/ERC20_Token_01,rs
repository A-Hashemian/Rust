use frame_support::{
    decl_error, decl_event, decl_module, decl_storage,
    dispatch::{DispatchResult, Vec},
    ensure,
};
use frame_system::{self as system, ensure_signed};
use sp_runtime::{ModuleId, traits::{AccountIdConversion, Zero}};


decl_storage! {
    trait Store for Module<T: Trait> as Token {
        // Storage for the balance of an account.
        Balances: map hasher(blake2_128_concat) T::AccountId => T::Balance;
        // Storage for the total supply of the token.
        TotalSupply: T::Balance;
    }
}

decl_event!(
    pub enum Event<T> where
        AccountId = <T as frame_system::Trait>::AccountId,
        Balance = <T as Trait>::Balance,
    {
        // Event emitted when tokens are transferred between accounts.
        Transfer(AccountId, AccountId, Balance),
        // Event emitted when an approval is made for an account to spend tokens.
        Approval(AccountId, AccountId, Balance),
    }
);

decl_error! {
    pub enum Error for Module<T: Trait> {
        // Error returned when an account does not have enough balance to complete a transfer.
        InsufficientBalance,
    }
}

decl_module! {
    pub struct Module<T: Trait> for enum Call where origin: T::Origin {
        // The ID of the module, used for generating events.
        const ModuleId: ModuleId = ModuleId(*b"mytoken ");
        // The account ID that the token is associated with.
        const AccountId: T::AccountId = T::ModuleId::get().into_account();
        // The balance type for the token.
        type Balance = T::Balance;
        // The maximum amount that can be transferred in a single transaction.
        const MaxTransferAmount: Balance = T::MaxTransferAmount::get();
        fn deposit_event() = default;
        // Transfers tokens from one account to another.
        #[weight = 10_000]
        pub fn transfer(origin, to: T::AccountId, value: Balance) -> DispatchResult {
            let from = ensure_signed(origin)?;
            Self::transfer_impl(&from, &to, value)?;
            Ok(())
           
        }
        
        
          // Approves an account to spend a certain amount of tokens on behalf of the token owner.
        #[weight = 10_000]
        pub fn approve(origin, spender: T::AccountId, value: Balance) -> DispatchResult {
            let owner = ensure_signed(origin)?;
            <Module<T>>::approve_impl(&owner, &spender, value)?;
            Ok(())
        }
        
        [weight = 10_000]
        pub fn transfer_from(origin, from: T::AccountId, to: T::AccountId, value: T::Balance) -> DispatchResult {
        // Verify that the origin is signed and get the signer's account ID.
        let sender = ensure_signed(origin)?;
        
        
        }
        
        // Call the transfer from implementation function.
        Self::transfer_from_impl(&sender, &from, &to, value)?;
        
        // Emit a `Transfer` event.
        Self::deposit_event(RawEvent::Transfer(from, to, value));
        
        Ok(())
        
        }
        
        // Implementation functions for transfer, approve, and transfer_from.

       impl<T: Trait> Module<T> {
       fn transfer_impl(from: &T::AccountId, to: &T::AccountId, value: T::Balance) -> DispatchResult {
       // Verify that the sender has enough balance to complete the transfer.
       let balance = Self::balances(from);
       ensure!(balance >= value, Error::<T>::InsufficientBalance);
           // Subtract the transferred amount from the sender's balance.
       <Balances<T>>::mutate(from, |balance| *balance -= value);

       // Add the transferred amount to the recipient's balance.
       <Balances<T>>::mutate(to, |balance| *balance += value);

      Ok(())
        }
