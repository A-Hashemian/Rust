use frame_support::{
    decl_error, decl_event, decl_module, decl_storage,
    dispatch::{DispatchResult, Vec},
    ensure,
};
use frame_system::{self as system, ensure_signed};
use sp_runtime::{ModuleId, traits::{AccountIdConversion, Zero}};


decl_storage! {
    trait Store for Module<T: Trait> as Token {
        // Storage for the balance of an account.
        Balances: map hasher(blake2_128_concat) T::AccountId => T::Balance;
        // Storage for the total supply of the token.
        TotalSupply: T::Balance;
    }
}

decl_event!(
    pub enum Event<T> where
        AccountId = <T as frame_system::Trait>::AccountId,
        Balance = <T as Trait>::Balance,
    {
        // Event emitted when tokens are transferred between accounts.
        Transfer(AccountId, AccountId, Balance),
        // Event emitted when an approval is made for an account to spend tokens.
        Approval(AccountId, AccountId, Balance),
    }
);

decl_error! {
    pub enum Error for Module<T: Trait> {
        // Error returned when an account does not have enough balance to complete a transfer.
        InsufficientBalance,
    }
}

decl_module! {
    pub struct Module<T: Trait> for enum Call where origin: T::Origin {
        // The ID of the module, used for generating events.
        const ModuleId: ModuleId = ModuleId(*b"mytoken ");
        // The account ID that the token is associated with.
        const AccountId: T::AccountId = T::ModuleId::get().into_account();
        // The balance type for the token.
        type Balance = T::Balance;
        // The maximum amount that can be transferred in a single transaction.
        const MaxTransferAmount: Balance = T::MaxTransferAmount::get();
        fn deposit_event() = default;
        }
